#!/usr/local/bin/perl
########################################################################
# Copyright (C) 1998-2000 Raydiant
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public LIcense
# as published by the Free Software Foundation;  either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
########################################################################

($VHome = $0) =~ s/([^\/]*)$//;
$VHome = "." if ( $VHome eq "");

require "${VHome}/fileutils.pl";
require "${VHome}/getopts.pl";

use File::Basename;

use subs qw/copyright module ports force wires regs connect portmap instance endmodule/;
use subs qw/script vpp vprint vprintf/;

use vars qw/%inputs %outputs %bidirs %signals %direction @instances/;
use vars qw/$pass $filename $prefix $verbose $clean %connection @files/;
use vars qw/%bus_lsb %bus_msb %wirelist %maplist $progName/;
use vars qw/$parenColumn $commentColumn $tabSize @moduleList/;
use vars qw/$CONVICT $VPORTS/;
use vars qw/%forced/;

# I'm not using "use strict", because it complicates user code that is eval()'ed.
# If I forced the user to be conscientous with "use vars" and "my", then "use
# strict" would work ok.

#use strict;

$progName = basename($0);
$CONVICT = $progName;
$CONVICT =~ s/\.[^\.]*$//;
$CONVICT =~ tr/a-z/A-Z/;

$VPORTS = "${VHome}ports";

&Getopts('hcvn');

$clean = $opt_c;
$verbose = $opt_v;
&usage if ($opt_h);

@files = @ARGV;

close IN;
close STDIN;

foreach $filename ( @files ) {

    $autoPortGen = 0;
    $prefix = "";
    $matrix = on;

    #default spacing...
    $commentColumn = 60;
    $parenColumn = 30;
    $tabSize = 3;

    print STDERR "************* processing: $filename (pass 0)\n" if ($verbose);

    open (IN, "<$filename") || 
        die "unable to open $filename";
    # Dummy file....
    open (STDOUT, ">Tmp1_$$") || 
        die "unable to open temp file for $filename";
    $pass = 0;
    &splitfile;
    close (IN);
    unlink "Tmp1_$$";

    #do it for real (2nd pass)
    print STDERR "************* processing: $filename (pass 1)\n" if ($verbose);

    $pass = 1;
    open (IN, "<$filename") || 
        die "unable to open $filename";
    
    open (STDOUT, ">Tmp2_$$") || 
        die "unable to open temp file for $filename";
    &splitfile;
    close(STDOUT);
    close (IN);
    
    my $diffs = 0;
    open (DIFFIT, "diff Tmp2_$$ $filename |");
    while (<DIFFIT>) { print STDERR if ($opt_n); $diffs++; }
    close (DIFFIT);
    if ($opt_n) {
        printf STDERR "$progName: $filename %s\n", ($diffs) ? "needs update!" : "is up-to-date";
        unlink "Tmp2_$$";
    } else {
        if ($diffs) {
            rename("Tmp2_$$",$filename) || 
                die "unable to update $filename";
        } else {
            unlink "Tmp2_$$";
        }
    }

    &reset();
}

exit 0;

###################################################

sub usage {

    print "
usage: $progName [-hcvn]  file1 ... fileN

       -h     print this help message
       -v     verbose runtime messages
       -n     diffs output with existing file, outputs if file is up-to-date or needs update
       -c     clean the files (i.e., remove any output generated by $progName)

Synopsys
========

$progName generates module connectivity information for RTL files.  
It also allows generic Perl scripts to be embedded in an RTL file.


Syntax
======

All commands must be bracketed between BEGIN PERL/END PERL as follows
   // ${CONVICT}: BEGIN PERL
   // <$progName directives and/or Perl code goes here>
   // ${CONVICT}: END PERL

For one-line commands, the syntax can be abbreviated to
   // ${CONVICT}: <$progName directives and/or Perl code goes here>

The resulting output is bracketed by 
   // ${CONVICT}: BEGIN GENERATED
   // ${CONVICT}: END GENERATED


Directives
==========

   copyright \"Company Name\"

        prints a copyright message.  The one-liner \"// ${CONVICT}: &copyright ...\"
        is a shortcut for printing the copyright message.

   module \"filename\"
        
        looks for inputs, outputs, and bi-directs.  Then prints the Verilog
        module statement and portlist.  The one-liner \"// ${CONVICT}: &module ...\" 
        is a shortcut.  Also useful for leaf cells just to generate the
        module and portlist verilog when I/Os are explicitly specified.

   ports

        prints out top-level ports, autogenereated based on connectivity of
        instantiated modules.  If an output is desired when it is also exists
        as an input and output of instantiated modules, the force command can
        be used to generate the port.

   wires
        
        Useful for wrapper files, simply prints all internal wire declarations.

   regs
        
        Useful for leaf cells, regs will print out reg statements for all
        module outputs.  This command should not be used for wrapper files.

   instance \"filename\" [, \"instancename\"]

        instantiates a module.  filename is the name of the file containing 
        the module.  The name of the module must match the basename of the 
        file.  If instancename isn't specified, the instance name becomes u_ 
        concatenated with the basename of filename.

   connect \"portname\", \"wirename\"

        specify connection to a port.  By default, ports are connected to the 
        wire of the same name.  portname is formed by concatenating the instance
        name, a period, and the port name.  If the instance name and following
        period aren't specified, the previous module instantiated with the 
        \"instance\" directive is assumed.  Example: for port \"stall\" of the 
        \"u_mod\" module instance, portname is \"u_mod.stall\".

   portmap \"regexp\", \"substitution\"

        define a regular expression for mapping portnames to another string.
        To specify the change for only a specific instance, preface the regexp
        with the instancename, similar to the usage of connect.  If no
        instance name is specified, portmap will default to all instances.

        Example 1:  portmap \'(ddr)_(\\w+)\', \'mychip_\$1bus_\$2\' 
        This will map a port called ddr_addr_out to mychip_ddrbus_addr_out
        for any instantiated instance.

        Example 2:  portmap \'u_memintf\\.(ddr)_(\\w+)\', \'mychip_\$1bus_\$2\' 
        This will map a port called ddr_addr_out to mychip_ddrbus_addr_out
        only for the instance u_memintf.  Note the backslach to explicitly
        match the \".\" character, since it has special meaning in regexps.

        Single quotes are useful to preserve backslashes, etc.  Currently
        portmap will take effect only if the port has its default connection,
        so an explicit mapping with the connect directive will take precedence.
        If multiple portmap directives map to the same port, the final portmap
        directive will take precedence (latest is greatest).

   portcomment \"portname\", \"comment string\"

        This directive allows a comment to be printed after a top-level port
        when the ports directive is used to autogenerate ports.

        Example:  portcomment \'reset\' \'synopsys sync_set_reset \"reset\"\'
        will print the following for an input called \"reset\"

        input  reset;  // synopsys sync_set_reset \"reset\"


   force \"input|output|inout|wire\", \"signalname\"
        
        force top-level inputs, outputs, and bi-directs.  Default is to assume
        a signal that connects to an input of one module and an output of another
        is an internal wire.  This directive will force a top-level port.  Legal
        port directions are \"input\", \"output\", or \"inout\".  Can also be used
        to force \"wire\" if the desire is to suppress top-level port generation.

   endmodule
        
        simply prints the endmodule statement

   script \"unix cmdline\"
        
        embed the output of a unix commandline in the output file.  This is useful
        for scripts that autogenerate fifos, etc.  ${CONVICT} can be used to keep
        these files up-to-date when the scripts that generated them are updated.

   matrix \"on|off\"
        
        enable printing of the connectivity matrix.  Default is \"on\"

   vpp \"cmd\",\"inc1\",\"inc2\",...

        use vpp to evaluate cmd given the specified include files (most likely 
        they'll be .vh files)

   vprint, vprintf

        use like Perl's buildin print and printf functions.  They prepend spaces
        so your generated text is indented as far as the \"${CONVICT}: BEGIN PERL\" 
        directive.


Example
=======

instantiate 3 instances of mod, named A, B, and C.  Let mod have one input
IN, and one output OUT.  For each instance, wire the IN signal to the IN port.  
Wire Aout, Bout, and Cout to the OUT port on A, B, and C, respectively.

   // ${CONVICT}: BEGIN PERL
   // instance \"mod.v\",\"A\";
   // instance \"mod.v\",\"B\";
   // instance \"mod.v\",\"C\";
   // connect \"A.OUT\",\"Aout\";
   // connect \"B.OUT\",\"Bout\";
   // connect \"C.OUT\",\"Cout\";
   // ${CONVICT}: END PERL

Or, you can be fancy and do it this way

   // ${CONVICT}: BEGIN PERL
   // foreach \$i (\"A\",\"B\",\"C\") {
   //     instance \"mod.v\",\$i;
   //     connect \".OUT\",\$i.\"out\";
   // }
   // ${CONVICT}: END PERL

in either case, the output is 


   // ${CONVICT}: BEGIN GENERATED
   mod A ( 
           .IN(IN),
           .OUT(Aout)
   );

   mod B ( 
           .IN(IN),
           .OUT(Bout)
   );

   mod C ( 
           .IN(IN),
           .OUT(Cout)
   );

   // ${CONVICT}: END GENERATED
";
    exit 1;
}

########################################################################
# Support functions
########################################################################

sub reset {
# clear globals in case of multiple Perl sections per file
    undef %inputs;
    undef %outputs;
    undef %bidirs;
    undef %signals;
    undef %direction;
    undef @modules;
    undef @instances;
    undef %connection;
    undef %portcomment;
    undef %forced;
    undef @moduleList;
    undef %wirelist;
    undef %maplist;
    undef %bus_msb;
    undef %bus_lsb;
}

sub vprint {
    my @args = @_;
    for (@args) { s/\n/\n${prefix}/sg; }
return print(@args);
}

sub vprintf {
    my @args = @_;
    for (@args) { s/\n/\n${prefix}/sg; }
return printf(@args);
}

sub spaces {
    my $c = $_[0];
    my $d = ( $c > 0 ) ? " " x $c : "";
}

sub dashes {
    my $c = $_[0];
    my $d = ( $c > 0 ) ? "-" x $c : "";
}

sub basesigname {
	 my $str = $_[0];
	 my $i;
	 
	 if ( $str =~ m/\[/ ) {
		  $i = index($str, "[");
		  $str = substr($str, 0, $i);
	 }

    $str;
}
	 
sub basebusname {
	 my $str = $_[0];
	 my $i;
	 
	 if ($str =~ m/\[/ ) {
		  $i = index($str, "[");
		  $str = substr($str, $i);
	 }
	 else {
        $str = "";
	 }

    $str;
}

sub getmin {
    my $str = $_[0];
    my $bus = basebusname($str);
    my $i;
    my $c;
        
    if ($bus ne '') {
        if ( $bus =~ m/\:/ ) {
            $i = index($bus, ":");
            $c = substr($bus, $i + 1);
            chop ($c);
            return $c;
        }
        else {
            $c = substr($bus, 1);
            chop ($c);
            return ($c);
        }
    }
    else {
        return 0;
    }
}

sub getmax {
    my $str = $_[0];
    my $bus = basebusname($str);
    my $i;
    my $c;
        
    if ($bus ne '') {
        if ( $bus =~ m/\:/ ) {
            $i = index($bus, ":");
            $c = substr($bus, 1, $i);
            chop ($c);
            return $c;
        }
        else {
            $c = substr($bus, 1);
            chop ($c);
            return $c;
        }
    }
    else {
        return 0;
    }
}

sub min {
    my ($a, $b) = @_;

    return $a if ($a < $b);
    return $b;
}

sub max {
    my ($a, $b) = @_;

    return $a if ($a > $b);
    return $b;
}

sub constant {
    my ($p) = @_;

    return (($p =~ /^(\d)*\'[bdoh][0-9a-fA-F_]*$/) ||
            ($p =~ /^$/)) ? 1 : 0;
}


########################################################################
# Support Functions
########################################################################

# -----------------------------------------------------------------
# parse the input file to extract ${CONVICT} commands and evaluate
# them.  This is a two-pass approach, first pass parses input files
# and build a connectivity matrix, and second pass prints out the
# resulting generated file.
# -----------------------------------------------------------------

sub splitfile {
    my $in_convict = 0;
    my $ignore = 0;
    my $userInput = "";

#        print STDERR "${CONVICT} PASS $pass\n";

    while (<IN>) {
        if ( m/${CONVICT}\s*:/ ) {
            
            if ( m/BEGIN GENERATED/ ) {
                $ignore = 1;
                
            } elsif ( m/END GENERATED/ ) {
                $ignore = 0;
                
            } elsif ( m/BEGIN PERL/ && !$ignore) {
                ($prefix = $_) =~ s/^(\s*).*$/\1/g; chop($prefix); # leading spaces
                $in_convict = 1;
                print "$_";
                
            } elsif ( m/END PERL/ && !$ignore) {
                $in_convict = 0;
                vprint "$_";
                if ( ! $clean ) {
                    vprint "// ${CONVICT}: BEGIN GENERATED\n";
                    eval $userInput;
                    die "$filename: $@" if $@;
                    print "// ${CONVICT}: END GENERATED\n";
                    $userInput = "";
                }
                
            } else {
                # one-line commands
                ($prefix = $_) =~ s/^(\s*).*$/\1/g; chop($prefix); # leading spaces
                vprint "$_";
                if ( ! $clean ) {
                    vprint "// ${CONVICT}: BEGIN GENERATED\n";
                    s/^.*${CONVICT}\s*:\s*//g;
                    eval $_;
                    die "$filename: $@" if $@;
                    print "// ${CONVICT}: END GENERATED\n";
                }
            }
            
        } else {
            if ( ! $ignore ) {
                print "$_";
                $userInput .= &decomment($_) if ( $in_convict );
            }
        }
    }
    &createConnectionMatrix if($pass == 0);
}

# -----------------------------------------------------------------
# getports calls $VPORTS program to scan the existing text of a file
# to determine the portlist.  Primarily used for instantiated modules
# in the populate subroutine, it is also used for top-level port 
# generation when &ports is not called to autogenerate them
# -----------------------------------------------------------------

sub getports {
    my $file = $_[0];
    my @words;
    my $bus;
    my $msb;
    my $lsb;
    my $signal;
    my $fullName;
	 my $i;
    my $intask;

    undef %inputs;
    undef %outputs;
    undef %bidirs;

    if ( exists $ENV{INCDIRS} ) {
        my @d = split(/:+/,$ENV{INCDIRS});
        $fullName = &FindFile($file,@d);
        $fullName = $file if ( $fullName eq "" );
    } else {
        $fullName = $file;
    }
printf("++++++++++++++++++++++++++++++++++++\n");
printf("VPORTS = %s\n", $VPORTS);
printf("fullname = %s\n", $fullName);
    open (PPORT, "perl $VPORTS $fullName |") ||
        die "unable to get ports for $fullName";
    
    $intask = 0;

    while (<PPORT>) {
        
        @words = split(/\s/, $_);

        if ($#words < 2) {
            $bus = "";
        } else {
				$bus = "";
				$i = $#words;
				for ($i = 2; $i <= $#words; $i = $i + 1) {
					 $bus = $bus . $words[$i];
				}
        }

        if ($bus =~ /\[(.+)\]/ ) {
            if ($bus =~ /\[(.+):(.+)\]/) {
                $msb = $1; $lsb = $2; 
            } else {
                $msb = $1; $lsb = $1; 
            }
            $msb = eval($msb) if ($msb =~ /[-+*\/\(\)]/);
            $lsb = eval($lsb) if ($lsb =~ /[-+*\/\(\)]/);
            $bus = "[$msb:$lsb]";
        }
        
        $signal = $words[1];

        if ($words[0] eq 'i') {
            $inputs{$signal} = $bus if (!$intask);
        }
        elsif ($words[0] eq 'o') {
            $outputs{$signal} = $bus if (!$intask);
        }
        elsif ($words[0] eq 'b') {
            $bidirs{$signal} = $bus if (!$intask);
        }
        elsif ($words[0] eq 'f') {
            $intask = $intask + 1;
        }
        elsif ($words[0] eq 't') {
            $intask = $intask + 1;
        }
        elsif ($words[0] eq 'ef') {
            $intask = $intask - 1;
        }
        elsif ($words[0] eq 'et') {
            $intask = $intask - 1;
        }
        elsif ($words[0] eq 'em') {
            $intask = $intask + 1;
        }
    }

    close(PPORT) || die "error getting ports for $fullName: $! $?";
}

# -----------------------------------------------------------------
# Populate the connectivity matrix.
# 
# give one argument for top level, both arguments for instantiated modules.
# For instances getports is called to generate an iolist, after which
# directions are recorded for the connection matrix.  Top-level directions
# are generated if we are not autogenerating the top-level portlist.
# -----------------------------------------------------------------

sub populate {
    my ($fileName,$instName) = @_;
    my ($i,$uname,$def_connect);
    
    undef %inputs;
    undef %outputs;
    undef %bidirs;

    $i = index($fileName, ".");
    $uname = ( $instName eq '' ) ? "" : $instName . ".";

    if($pass == 0)
    {
        getports($fileName) unless (($instName eq '') && ($autoPortGen));

        push (@instances, $instName);

        foreach $i (keys %inputs) {
            $def_connect = $uname.$i;
            $signals{$def_connect} = $i.$inputs{$i};
            $direction{$def_connect} = "i";
        }
        
        foreach $i (keys %outputs) {
            $def_connect = $uname.$i;
            $signals{$def_connect} = $i.$outputs{$i};
            $direction{$def_connect} = "o";
        }
        
        foreach $i (keys %bidirs) {
            $def_connect = $uname.$i;
            $signals{$def_connect} = $i.$bidirs{$i};
            $direction{$def_connect} = "b";
        }
    }
}

# -----------------------------------------------------------------
# Print the connectivity matrix as a comment in the output verilog
# -----------------------------------------------------------------

sub printConnectionMatrix {
    my @lclinst = @instances;
    my $mod;
    my $modnum = $#moduleList;
    vprint "// CONNECTIVITY MATRIX\n";
    # Print them in reverse...
    foreach $mod (@moduleList) {              
        vprint @moduleList[$modnum]."\n";
        $modnum--;
    }
}

# -----------------------------------------------------------------
# Loop through instantiated modules and generate port connectivity
# Top-level module is processed last, and ports are optionally
# autogenerated based on instance connectivity.
#
# This subroutine generates the internal wirelist and processes
# any mapping constructs from portmap directives.  Each wire is
# given a connection matrix comment that can later be printed by
# the instance directive.
# -----------------------------------------------------------------

sub createConnectionMatrix {
    my $instanceName;
    my $i;
    my $str;
    my $tmp;
    my $len;
    my $port;
    my $c;
    my $lstr;
    my ($pf,$pfmod,$bars,$tmp,$name);

    my $instanceNumber = $#instances;

    foreach $instanceName (reverse @instances) {
	
        $tmp = $instanceName.".";
        my $isTopLevel = ($tmp eq ".") ? 1 : 0;

        print STDERR "looking for signals in $tmp\n" if ( $verbose );

        @inputs = ();
        @outputs = ();
        @inouts = ();

        &genports($tmp);

        foreach $c ( @inputs, @inouts, @outputs ) {
            my ($lsb, $msb);
            my ($min, $max);
            my @wires;
            my $q;
            my $p;

            my $def_connect = $c;
            $def_connect =~ s/^$instanceName\.//;
            if ($signals{basesigname($c)} =~ /^$def_connect(\[.+\])?$/) {
                foreach $mapping (keys %maplist) {
                    if ($c =~ /^$mapping$/) {
                        $target_name = $maplist{$mapping};
                        $map_name = eval "\"$target_name\"";
                        $map_name .= basebusname($signals{basesigname($c)}) 
                            if (($map_name !~ /\[(.+)\]/) &&
                                ($map_name !~ /\{/) &&
                                !(constant($map_name)));
                        $signals{basesigname($c)} = $map_name;
                    }
                }
            }

            $q = $signals{basesigname($c)};

            $q =~ s/\{(\d)*\{//g;
            $q =~ s/\{//g;
            $q =~ s/\}//g;
            $q =~ s/,/ /g;
            
            @wires = split(/\s/, $q);

            foreach $p (@wires) {
                next if constant($p);

                if ($p =~ /\[(.+):(.+)\]/) {
                    $msb = $1; $lsb = $2; 
                } elsif ($p =~ /\[(.+)\]/){
                    $msb = $1; $lsb = $1; 
                } else {
                    $lsb = ""; $msb = "";
                }
                $msb = eval($msb) if ($msb =~ /[-+*\/\(\)]/);
                $lsb = eval($lsb) if ($lsb =~ /[-+*\/\(\)]/);

                $p =~ s/\[.*\]//g;
                $p =~ s/\{//g;
                $p =~ s/\}//g;

                if (exists $wirelist{$p}) {
                    my $w = $wirelist{$p};
                    if ($w =~ /\[(.+):(.+)\]/) {
                        $max = $1; $min = $2; 
                    } elsif ($w =~ /\[(.+)\]/){
                        $max = $1; $min = $1; 
                    } else {
                        $max = ""; $min = "";
                    }
                } else {
                    $max = ""; $min = "";
                }
                $max = eval($max) if ($max =~ /[-+*\/\(\)]/);
                $min = eval($min) if ($min =~ /[-+*\/\(\)]/);
                $max = $msb if (($max eq "") || ($msb > $max));
                $min = $lsb if (($min eq "") || ($lsb < $min));

                $wirelist{$p} = ($max eq "") ? "" : ($max == $min) ? "[$max]" : "[$max:$min]"
                    if (!$isTopLevel);

                $connection{$p} = &dashes($#instances+1) if(!exists $connection{$p});
            
                # Auto space for comment (fix)
                my @concat = split(/,/, $signals{$c});
                foreach $concat (@concat) {
                    $str = &spaces($parenColumn+1)."(".$concat."),    ";
                    $lstr = length($str);
                    $commentColumn = ($lstr) if($lstr >= $commentColumn); 
                }

                substr($connection{$p},$instanceNumber,1) = $direction{$c};
                printf STDERR "%s: connecting %s [%s:%s] to %s\n",$tmp,$p,$msb,$lsb,$direction{$c}
                if ($verbose);
            }
            
        }                 
        $instanceNumber --;
    }

# Construct the string for later
    $instanceNumber = 0; 
    $pf = 0; $pfmod = 1; #variables to control the spacing of lines (set to every other)
    $bars = "| " x 64; #note that it is bar then a space (every other)

    foreach $instanceName (@instances) {
        $str = "// $instanceName";
        $i = $commentColumn - (length($instanceName)) + $instanceNumber; 
        $str .= &dashes($i) if($pf == 0);
        $str .= &spaces($i) if($pf > 0);
        $pf++; $pf = 0 if($pf >$pfmod);

        push @moduleList ,$str.substr($bars, $instanceNumber, $#instances - $instanceNumber + 1);
        $instanceNumber++;
    }
}

# -----------------------------------------------------------------
# Called by createConnectionMatrix, genports has most of the
# intelligence for generating top-level ports if &ports is specified,
# this is also where the force construct has its effect.  If ports
# are not auto-generated, genports simply creates arrays for 
# inputs, outputs, and bidirs based on information previously 
# collected with populate and getports.  Wires promoted to 
# top-level IOs are deleted from the wirelist.
# -----------------------------------------------------------------

sub genports {
    my ($tmp) = @_;
    my @ports;
    my $sig;


    if ( $tmp eq "." ) { 

        # TOP LEVEL (should be processed last)
        # this way the wirelist, connection, signals hashes 
        # are already populated for all instantiated modules

        if (! $autoPortGen) {
            @ports = grep(!/\./, keys %signals);
            foreach $c (sort @ports) { 
                topports ("i", $signals{$c}) if ( $direction{$c} eq "i");
                topports ("o", $signals{$c}) if ( $direction{$c} eq "o");
                topports ("b", $signals{$c}) if ( $direction{$c} eq "b");
            }
        } else {
            # this is necessary because we could be forcing a signal
            # from an assign, or something not in the connection matrix.
            foreach $c (keys %forced) {
                topports ("i", $c) if ($forced{$c} eq "input");
                topports ("o", $c) if ($forced{$c} eq "output");
                topports ("b", $c) if ($forced{$c} eq "inout");
            }
            foreach $c (keys %connection) { 
                $sig = $c.$wirelist{$c};
                topports ("i", $c) if (!($connection{$c} =~ /[ob]/) &&
                                       !(exists $forced{$sig}));
                topports ("o", $c) if (!($connection{$c} =~ /[ib]/) &&
                                       !(exists $forced{$sig}));
                topports ("b", $c) if (($connection{$c} =~ /[b]/) &&
                                       !(exists $forced{$sig}));
            }
            @inputs  = (sort @inputs);
            @outputs = (sort @outputs);
            @inouts  = (sort @inouts);
        }
    }else{
        chop($tmp);  # need to grep with the literal "."
        @ports= grep(/^$tmp\./,keys %signals);
        foreach $c (sort @ports) { 
            push @inputs,$c if ( $direction{$c} eq "i");
            push @outputs,$c if ( $direction{$c} eq "o");
            push @inouts,$c if ( $direction{$c} eq "b");
        }
    }
}

# -----------------------------------------------------------------
# helper function for genports to push signals to top-level IOs.
# also set up direction array and clean up wirelist, etc.
# -----------------------------------------------------------------

sub topports {
    my ($dir, $name) = @_;
    my $sig = basesigname($name).$wirelist{basesigname($name)};

    push @inputs, $sig if ($dir eq "i");
    push @outputs, $sig if ($dir eq "o");
    push @inouts, $sig if ($dir eq "b");

    $direction{$sig} = $dir;
    delete $wirelist{basesigname($name)};
    $signals{basesigname($name)} = $sig 
        if (!exists $signals{basesigname($name)});
}

sub vpp {
    my ($str,@files) = @_;
    my $cmd = "";
    my $result;

    foreach (@files) { 
		  my @d = split(/:+/,$ENV{INCDIRS});
		  $f = &FindFile($_,@d);
		  $f = $_ if ( $f eq "" );
		  $cmd .= "`include \"${f}\"\\n"; 
    }
    $cmd .= $str . "\\n";
    $cmd = quotemeta($cmd);
#    warn "vpp cmd is ",$cmd,"\n";
    $result = `/bin/echo $cmd | vpp - 2>/dev/null`;
    die "error evaluating \"$str\" in $filename, $? ,$!" if $?;
    chop($result);
#    warn "vpp result is ",$result,"\n";
    return $result;
}

# -----------------------------------------------------------------
# remove leading comment delimiters from perl directives
# -----------------------------------------------------------------

sub decomment {
    my $l = @_[0];

    $l =~ s#^\s*//##g if ( m#^\s*//# );

    return $l;
}

########################################################################
# Main user tasks
########################################################################

# -----------------------------------------------------------------
# Control for printing connection matrix (default is "on")
# matrix "off" will disable printing the connection matrix
# -----------------------------------------------------------------

sub matrix {
    $matrix = $_;
}

# -----------------------------------------------------------------
# Print module header and portlist for current file
# -----------------------------------------------------------------

sub module {
    my $i;
    my $modname;
    my $c;
    my $str;
    my $space;
	 my $maxsize;

    $i = index($filename, ".");
    $modname = substr($filename, 0, $i);
	 
    if($pass == 0) {
        &populate($filename); # DO NOT CALL WITH MORE THAN ONE ARG HERE!
	 } else {
        $str = "module $modname ( ";
        $i = length($str) + 1; # indent ports one char past left paren
        
        $str .= "\n" . &spaces($i) . "// inputs" if ( $#inputs >=0);
        foreach $c (@inputs) {
            if($c =~ /^[a-zA-Z_]/) {  # changed 2012/12/03 to remove `define in top level input and output
               vprint "$str\n";
               $space = &spaces($i);
               $space = $space . basesigname($c);
               $str = "$space,";
            }
		  }
        
        $str .= "\n\n" . &spaces($i) . "// outputs" if ( $#outputs >=0);
        foreach $c (@outputs) {
            if($c =~ /^[a-zA-Z_]/) {   # changed 2012/12/03 to remove `define in top level input and output
               vprint "$str\n";
               $space = &spaces($i);
               $space = $space . basesigname($c);
               $str = "$space,";
            }
        }
        
        $str .= "\n\n" . &spaces($i) . "// inouts" if ( $#inouts >=0 );
				foreach $c (@inouts) {
            vprint "$str\n";
            $space = &spaces($i);
            $space = $space . basesigname($c);
            $str = "$space,";
        }
        
        chop($str);
        vprint "$str\n";
        vprint ");\n";

    }
}

# -----------------------------------------------------------------
# Autogenerate top-level ports from the connection matrix and
# print out all inputs, outputs, and inouts.
# -----------------------------------------------------------------

sub ports {
    my $c;

    if($pass == 0) {
        $autoPortGen = 1;
	 } else {
        vprint "\n" if ( $#inputs >=0);
        foreach $c (@inputs) {
            if($c =~ /^[a-zA-Z_]/) {  # changed 2012/12/03 to remove `define in top level input and output
               vprintf "input   %-10s %s;",basebusname($c), basesigname($c);
               if (exists ($portcomment{basesigname($c)})) {
                   vprintf "  // %s\n",$portcomment{basesigname($c)};
               } else {
                   vprintf "\n";
               }
            }
        }
        
        vprint "\n" if ( $#outputs >=0);
        foreach $c (@outputs) {
            if($c =~ /^[a-zA-Z_]/) {  # changed 2012/12/03 to remove `define in top level input and output
               vprintf "output  %-10s %s;",basebusname($c),basesigname($c);
               if (exists ($portcomment{basesigname($c)})) {
                   vprintf "  // %s\n",$portcomment{basesigname($c)};
               } else {
                   vprintf "\n";
               }
            }
        }
        
        vprint "\n" if ( $#inouts >=0);
        foreach $c (@inouts) {
            vprintf "inout   %-10s %s;",basebusname($c),basesigname($c);
            if (exists ($portcomment{basesigname($c)})) {
                vprintf "  // %s\n",$portcomment{basesigname($c)};
            } else {
                vprintf "\n";
            }
        }
        
        vprint "\n\n";
    }
}

# -----------------------------------------------------------------
# Instantiate a module:  instName is optional.  If not specified,
# defaults to u_filename (minus the file extention)
# -----------------------------------------------------------------

sub instance {
    my ($fileName,$instName, $postfix) = @_;
    my ($modName);
    my ($parameters);
    my ($i,$c);
    $parameters = "";
    $instName =~ s/^\s+//;
    @param = split /[()]/, $instName;
    if( @param == 3){
       $instName = $param[2];
       $parameters = "#($param[1])";
    }
    else {
    }

 
    $i = index($fileName, ".");
    $modName = substr($fileName, 0, $i);
    
    if ($#_ == 0) {
        $instName = "u_".$modName;
    }
    
    print STDERR "Getting module instance info for $modName ($instName)\n" if ($verbose);
    if ($pass == 0) {
        &populate($fileName, $instName);
    } else {
    
        #   DUMP INSTANCE REPLACEMENT
        print STDERR "Instantiating module instance info for $modName ($instName) ($commentColumn)\n" if ($verbose);
    
        my $str = "$modName $parameters $instName (";
        $i = 3;
        my $space = &spaces($i);
        my $len = length($instName.".");
    
        my @inputs = ();
        my @outputs = ();
        my @inouts = ();
        my @ports = grep(/^$instName\./,keys %signals);
 
        foreach $c (sort @ports) { 
            print STDERR "Working on Port ($c) in $instName\n" if ($verbose);
            push @inputs,$c if ( $direction{$c} eq "i");
            push @outputs,$c if ( $direction{$c} eq "o");
            push @inouts,$c if ( $direction{$c} eq "b");
        }
    
        sort(@inputs);
        sort(@outputs);
        sort(@inouts);

        my $lsignal = @outputs ? $outputs[$#outputs] : @inouts ? $inouts[$#inouts] : $inputs[$#inputs];
        my $firstoutput = $outputs[0];
        my $firstinout =  $inouts[0];

        my $comma = ",";
        my @wires;
        my ($port,$lport,$lstr,$overspace,$concat);

        &printConnectionMatrix if ($matrix eq on); 
    
        foreach $c ( @inputs, @inouts, @outputs ) {
	
            my $q = $signals{$c};
            my $p = $q;

            print STDERR "instance: working on $c port of $instName\n" if ( $verbose );
            $comma = "" if ( $c eq $lsignal );
            $str .= "\n" if ( $c eq $firstoutput || $c eq $firstinout); 
            vprint "$str\n";
            $port = substr($c, $len);
        
            # Auto Space function for left paren
            $lport = length($port);
            $parenColumn = ($lport +1) if($lport >= $parenColumn);
            $overspace = &spaces($parenColumn-$lport);
            $str = $space.".".$port.$overspace."(";

            if ($matrix eq on) {
                if ($q =~ /,/) {
                    my $cnt = 0;
                    $q =~ s/\s//g;
                    @wires = split(/,/, $q);

                    foreach $p (@wires) {
                        # Break out concatenated signals
                        my $r = $p;
                        my $last = ($cnt == $#wires);
                        my $newstr = "";
                        $r =~ s/\{\d+\{//g;
                        $r =~ s/\{//g;
                        $r =~ s/\}//g;

                        $concat = $space . &spaces($parenColumn+3);
                        $newstr .= $concat if ($cnt);
                        $newstr .= $p . ((!$last) ? ", " : ")".$comma);
                        $str .= $newstr;
                        $lstr = ($cnt) ? length($newstr) : length($str);
                        $overspace = &spaces($commentColumn-$lstr);
                        $r =~ s/\[.*\]//g;
                        $str .= $overspace."// ";
                        $str .= "$connection{$r}" if (!constant($r));
                        if (!$last) {
                            vprint "$str\n";
                            $str = "";
                        }

                        $cnt++;
                    }
                } else {
                    $str .= $signals{$c}.")".$comma;
                    $lstr = length($str);
                    $overspace = &spaces($commentColumn-$lstr);
                    $p =~ s/\[.*\]//g;
                    $str .= $overspace."// $connection{$p}";
                }
            } else {
                $str .= $signals{$c}.")".$comma;
            }
        }
        vprint "$str\n";
        vprint ");\n\n";
    }
}

# -----------------------------------------------------------------
# Force top-level connection as one of the following:
#   input/output/inout/wire
# -----------------------------------------------------------------

sub force {
	 my ($fdir,$fname) = @_;

    $forced{$fname} = $fdir;
    $wirelist{basesigname($fname)} = basebusname($fname);
}

# -----------------------------------------------------------------
# Portmap allows a regular expression substitution to be applied
# to ports of instantiated modules.  the source string and target
# string should be in single quotes to preseve backslashes, etc.
#
# portmap 'u_inst.(port[a-z])_out' 'my$1'
# would rename "porta_out" of instance u_inst as "myporta"
#
# If the instance preface is left out, the mapping applies to
# all instances.  More powerful than connect, below, it also
# runs quite a bit more slowly.  A hash called maplist is created
# and is later executed in the subroutine createConnectionMatrix.
#
# portmap works only on ports that have not already been reassigned
# with a connect directive. If multiple portmap directives map to
# a port, the final portmap directive takes precedence.
# -----------------------------------------------------------------

sub portmap {
    my ($source, $target) = @_;

    if($pass == 0) {
        $source = '\w*\.' . $source if ($source !~ /\\\./);
        $maplist{$source} = $target;
    }
}

# -----------------------------------------------------------------
# Connect provides a mechanism for connecting a port of an
# instantiated to a wire with a different name.
# -----------------------------------------------------------------

sub connect {
    my $port = $_[0];
    my $wire = $_[1];

    if($pass == 0) {
        printf STDERR "connecting $wire to port %s.$port\n",$instances[@instances-1]
            if ($verbose);

        $port = $instances[@instances-1] . "." . $port 
            if ( $port !~ /\./ ); # use last inst by default
        
        if (exists $signals{$port}) {
            $wire .= basebusname($signals{$port}) 
                if (($signals{$port} =~ /\[(.+)\]/) && 
                    ($wire !~ /\[(.+)\]/) &&
                    ($wire !~ /\{/) &&
                    !(constant($wire)));
            $signals{$port} = $wire;
        } else {
            warn "Non existing port $port in $filename\n";
        }
    }
}

# -----------------------------------------------------------------
# print out wires based on the connection matrix data
# -----------------------------------------------------------------

sub wires {
    my @wires = keys %wirelist; 

    if($pass == 1) {
        foreach $c (sort @wires) { 
            vprintf "   wire %-10s %s;\n",$wirelist{$c},$c;
        }
        print "\n";
    }
}

# -----------------------------------------------------------------
# print out reg statements for outputs in leaf modules
# -----------------------------------------------------------------

sub regs {
    if($pass == 1) {
        vprint "\n" if ( $#outputs >=0);
        foreach $c (@outputs) {
            vprintf "reg  %-10s %s;\n",$outputs{basesigname($c)},basesigname($c);
        }
        vprint "\n";
    }
}

sub endmodule {
    vprintf "endmodule\n" if ($pass == 1);
}

# -----------------------------------------------------------------
# Add a comment for a top-level port
# -----------------------------------------------------------------

sub portcomment {
    my ($port, $comment) = @_;

    $portcomment{basesigname($port)} = $comment;
}

# -----------------------------------------------------------------
# Print copyright header
# -----------------------------------------------------------------

sub copyright {
    my ($year, $company) = @_;

    my $vp = "
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) ${year}, ${company}.
// All Rights Reserved. 
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of ${company}; 
// the contents of this file may not be disclosed to third parties, copied or 
// duplicated in any form, in whole or in part, without the prior written 
// permission of ${company}.
// 
/////////////////////////////////////////////////////////////////////////////
// ";
    vprint "$vp\n";

}

# -----------------------------------------------------------------
# Embed output of an arbitrary script
# -----------------------------------------------------------------

sub script {
    my ($cmdline) = @_;

    if ($pass == 1) {
        open (SESAME, $cmdline . " |");
        while (<SESAME>) {
            vprint "$_";
        }
        close(SESAME);
    }
}
# -----------------------------------------------------------------
sub allports {
    my $ios;
    my ($fileName) = @_;
open (PPORT, "ports $fileName |") ||
   die "unable to get ports for $fileName";
   $ios{$fileName}={};
   while (<PPORT>) {
      @words = split(/\s/, $_);
      if ($#words < 2) {
         $bus = "";
      } else {
         $bus = "";
         $i = $#words;
         for ($i = 2; $i <= $#words; $i = $i + 1) {
             $bus = $bus . $words[$i];
         }
      }
      if ($bus =~ /\[(.+)\]/ ) {
          if ($bus =~ /\[(.+):(.+)\]/) {
              $msb = $1; $lsb = $2; 
          } else {
              $msb = $1; $lsb = $1; 
          }
          $msb = eval($msb) if ($msb =~ /[-+*\/\(\)]/);
          $lsb = eval($lsb) if ($lsb =~ /[-+*\/\(\)]/);
          $bus = "[$msb:$lsb]";
      }
      $signal = $words[1];
      if (  $words[0] eq 'i') {
         $ios{$fileName}{input}{$signal} = $bus;
      }
      if (  $words[0] eq 'o') {
         $ios{$fileName}{output}{$signal} = $bus;
      }
      if (  $words[0] eq 'b') {
         $ios{$fileName}{inout}{$signal} = $bus;
      }
   }
 close(PPORT) || die "error getting ports for $fileName";
 $ios; 
}

